{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\fmodern\fcharset0 CourierNewPS-BoldItalicMT;
\f3\fmodern\fcharset0 CourierNewPS-BoldMT;\f4\fmodern\fcharset0 CourierNewPS-ItalicMT;\f5\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red10\green65\blue216;\red171\green16\blue27;
\red169\green14\blue26;\red83\green83\blue83;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c1961\c35686\c87843;\cssrgb\c73333\c13725\c13725;
\cssrgb\c72941\c12941\c12941;\cssrgb\c40000\c40000\c40000;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \expnd0\expndtw0\kerning0
import re
\f1\fs32 \

\f0\fs25\fsmilli12667 import itertools
\f1\fs32 \

\f0\fs25\fsmilli12667 import multiprocessing
\f1\fs32 \
\pard\pardeftab720\li1920\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 from pyspark import StorageLevel
\f1\fs32 \

\f0\fs25\fsmilli12667 from pyspark.sql import functions as F
\f1\fs32 \

\f0\fs25\fsmilli12667 from pyspark.sql import SparkSession, types
\f1\fs32 \
\pard\pardeftab720\li960\ri878\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 from pyspark.sql.functions import col, isnan, when, count, udf
\f1\fs32 \

\f0\fs25\fsmilli12667 from pyspark.ml.feature import OneHotEncoder, StringIndexer, VectorAssembler
\f1\fs32 \
\pard\pardeftab720\li1920\ri878\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 from pyspark.ml import Pipeline
\f1\fs32 \
\pard\pardeftab720\fi960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 from pyspark.ml.regression import GeneralizedLinearRegression
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
\f1\fs32 \

\f0\fs25\fsmilli12667 from pyspark.ml.evaluation import BinaryClassificationEvaluator
\f1\fs32 \

\f0\fs25\fsmilli12667 from pyspark.ml.classification import LogisticRegression, LogisticRegressionModel
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\ri873\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 train_df = spark.read.parquet('s3://myawsbucketfolder/train.parquet',
\f1  
\f0 header=True, inferSchema=True)
\f1\fs32 \

\f0\fs25\fsmilli12667 label_df = spark.read.csv('s3://myawsbucketfolder/train_labels.csv', header=True, inferSchema=True)
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\fi-120\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 def add_suffix(names, suffix):
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 return [name + suffix for name in names]
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0\'a0 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0\'a0 
\f2\i\b # Known Columns
\f1\i0\b0\fs32 \
\pard\pardeftab720\li840\fi120\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 target_df \cf3 =\cf2  [\cf4 'target'\cf2 ]
\f1\fs32 \
\pard\pardeftab720\li746\fi213\sl380\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 info_df \cf3 =\cf2  [\cf4 'customer_ID'\cf2 , \cf4 'S_2'\cf2 ]
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 cat_df \cf3 =\cf2  [\cf4 'B_30'\cf2 , \cf4 'B_38'\cf2 ,\cf4 'D_114'\cf2 , \cf4 'D_116'\cf2 , \cf4 'D_117'\cf2 , \cf4 'D_120'\cf2 , \cf4 'D_126'\cf2 ,\cf4 'D_63'\cf2 ,\cf4 'D_64'\cf2 ,\cf4 'D_66'\cf2 ,\cf4 'D_68'\cf2 ]
\f1\fs32 \
\pard\pardeftab720\li749\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Define Numeric Columns
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\fi-120\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0excluded = info_df + cat_df
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0num_df = [col for col 
\f3\b in
\f0\b0  train_df.columns if col 
\f3\b not
\f0\b0  
\f3\b in
\f0\b0  excluded]
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li746\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Define Feature Columns
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 features = cat_df + num_df
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \

\f0\fs25\fsmilli12667 train_df = (train_df.fillna(0, subset=num_df)
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 .fillna("null", subset=cat_df))
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f4\i\fs25\fsmilli12667 \cf2 \'a0\'a0\'a0\'a0\'a0 
\f2\b # Create columns aliases
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 catindex \cf3 =\cf2  add_suffix(cat_df, \cf5 "_index"\cf2 )
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Fit StringIndexer
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 indexers = StringIndexer(inputCols=cat_df, outputCols= catindex)
\f1\fs32 \

\f0\fs25\fsmilli12667 indexers_model = indexers.fit(train_df)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Transform to data
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 train_df_indexed = indexers_model.transform(train_df)
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f4\i\fs25\fsmilli12667 \cf2 \'a0
\f1\i0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Create columns aliases
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 catVector \cf3 =\cf2  add_suffix(cat_df, \cf5 "_ohe"\cf2 )
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f4\i\fs25\fsmilli12667 \cf2 \'a0
\f1\i0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Fit OneHotEncoder
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 ohe = OneHotEncoder(inputCols=cat_index_cols, outputCols=cat_ohe_cols)
\f1\fs32 \

\f0\fs25\fsmilli12667 ohe_model = ohe.fit(train_df_indexed)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Transform to data
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 train_df_ohed = ohe_model.transform(train_df_indexed)
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs24 \cf2 \'a0
\f1\i0\b0\fs32 \

\f2\i\b\fs24 \'a0
\f1\i0\b0\fs32 \

\f2\i\b\fs24 \'a0
\f1\i0\b0\fs32 \

\f2\i\b\fs24 \'a0
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Functions for each type
\f1\i0\b0\fs32 \

\f2\i\b\fs25\fsmilli12667 # each tuple consist of: (function, column's suffix)
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 >>> num_funcs \cf3 =\cf2  [
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 mean, \cf5 "_mean"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 stddev, \cf5 "_std"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 min, \cf5 "_min"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 max, \cf5 "_max"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 ]
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \

\f0\fs25\fsmilli12667 >>> cat_funcs \cf3 =\cf2  [
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 count, \cf5 "_count"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 last, \cf5 "_last"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0\'a0\'a0 \'a0\'a0\'a0\'a0\'a0 (F\cf3 .\cf2 countDistinct, \cf5 "_nunique"\cf2 ),
\f1\fs32 \

\f0\fs25\fsmilli12667 ]
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Arguments for .agg method
\f1\i0\b0\fs32 \

\f2\i\b\fs25\fsmilli12667 # each arg consist of: func(colname).alias(colname + suffix)
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 agg_num_args = [
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 func(col).alias(col + suffix) 
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 for col, (func, suffix) in itertools.product(num_cols, num_funcs)]
\f1\fs32 \

\f0\fs25\fsmilli12667 agg_cols_args = [
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 func(col).alias(col + suffix) 
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 for col, (func, suffix) in itertools.product(cat_ohe_cols, cat_funcs)]
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f2\i\b\fs25\fsmilli12667 \cf2 # Combine numeric and categoric agg arguments
\f1\i0\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 agg_args \cf3 =\cf2  agg_num_args \cf3 +\cf2  agg_cols_args
\f1\fs32 \

\f0\fs25\fsmilli12667 agg_args[\cf6 0\cf2 ]
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\fi960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 unused_cols = cat_cols + num_cols + cat_index_cols + cat_ohe_cols
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \

\f0\fs25\fsmilli12667 # Apply the agg while also dropping unused columns
\f1\fs32 \

\f0\fs25\fsmilli12667 train_df_grouped = (train_df_ohed.groupBy("customer_ID")
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 .agg(*agg_cols_args)
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 .drop(*unused_cols))
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \

\f0\fs25\fsmilli12667 train_df = train_df.join(F.broadcast(label_df), on="customer_ID")
\f1\fs32 \
\pard\pardeftab720\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 va = VectorAssembler(
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 inputCols=train_joined_df.drop("customer_ID", "target").columns,
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 outputCol="features",
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0 handleInvalid="error",
\f1\fs32 \

\f0\fs25\fsmilli12667 ... )
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \

\f0\fs25\fsmilli12667 train_ready_df = (va.transform(train_joined_df)
\f1\fs32 \

\f0\fs25\fsmilli12667 ...\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 .select(["customer_ID", "features", "target"])
\f1\fs32 \
\pard\pardeftab720\li960\sa160\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 ...\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 .persist(StorageLevel.DISK_ONLY))
\f1\fs32 \
\pard\pardeftab720\fi960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create a label. =1 if default, =0 otherwise
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 train_ready_df= train_ready_df.withColumn("label", when(train_ready_df.target == 1, 1).otherwise(0))
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 \'a0
\f1\b0\fs32 \

\f3\b\fs25\fsmilli12667 # Split the data into training and test sets
\f5\b0 \uc0\u8232 
\f1\fs32 \
\pard\pardeftab720\li960\sa160\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 trainingData, testData = train_ready_df.randomSplit([0.7, 0.3])
\f1\fs32 \
\pard\pardeftab720\fi960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create a LogisticRegression Estimator
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 lr \cf3 =\cf2  LogisticRegression()
\fs24 \uc0\u8232 
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create the pipeline logistic regression (lr) is stage 0
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0\'a0pipeline = Pipeline(stages=[lr])
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create a grid to hold hyperparameters
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 grid = ParamGridBuilder()
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 grid = grid.addGrid(lr.regParam, [0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 grid = grid.addGrid(lr.elasticNetParam, [0, 0.5, 1])
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Build the parameter grid
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 grid = grid.build()
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # How many models to be tested
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 print('Number of models to be tested: ', len(grid))
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 Number of models to be tested:\'a0 18
\f1\fs32 \
\pard\pardeftab720\li1333\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create a BinaryClassificationEvaluator to evaluate how well the model works
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 evaluator = BinaryClassificationEvaluator(metricName="areaUnderROC")
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Create the CrossValidator using the hyperparameter grid
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 cv = CrossValidator(estimator=pipeline, 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 ... estimatorParamMaps=grid, 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 ... evaluator=evaluator, 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 ... numFolds=3)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Train the models
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 cv = cv.fit(trainingData)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Test the predictions\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 predictions = cv.transform(testData)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Calculate AUC
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 auc = evaluator.evaluate(predictions)
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 print('AUC:', auc)\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 
\f3\b AUC: 0.8762406874932296
\f1\b0\fs32 \

\f0\fs25\fsmilli12667 \'a0
\f1\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f3\b\fs25\fsmilli12667 \cf2 # Look at the parameters for the best model that was evaluated from the grid
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 parammap = cv.bestModel.stages[0].extractParamMap()
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 for p, v in parammap.items():
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 ...\'a0\'a0\'a0\'a0 print(p, v) 
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__aggregationDepth 2
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__elasticNetParam 0.5
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__family auto
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__featuresCol features
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__fitIntercept True
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__labelCol label
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__maxBlockSizeInMB 0.0
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__maxIter 10
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__predictionCol prediction
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__probabilityCol probability
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__rawPredictionCol rawPrediction
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__regParam 0.0
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__standardization True
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__threshold 0.5
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 LogisticRegression_c8b92d598a08__tol 1e-06\
\
\pard\pardeftab720\li960\partightenfactor0

\f3\b \cf2 # Look at the parameters for the best model that was evaluated from the grid
\f1\b0\fs32 \
\pard\pardeftab720\li960\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 parammap = cv.bestModel.stages[0].extractParamMap()
\f1\fs32 \

\f0\fs25\fsmilli12667 \'a0 for p, v in parammap.items():
\f1\fs32 \
\pard\pardeftab720\li960\sl380\partightenfactor0

\f0\fs25\fsmilli12667 \cf2 \'a0 ...\'a0\'a0\'a0\'a0 print(p, v)}